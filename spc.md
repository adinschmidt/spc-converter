# Pulsar SPC (SPC0) File Format Specification

> **Note**: This specification was reverse-engineered from the [Spectrum Analyzer Suite source code](https://www.open-raman.org/build/software/) and is not derived from official documentation. While it aims to be accurate, there may be discrepancies or undocumented edge cases.

This document describes the binary format of `.spc` files produced by the Spectrum Analyzer Suite.
The format consists of two layers:

1. **Container layer (SPC0 / StorageContainer)**: file header, checksum, encryption, and per-buffer compression.
2. **Object layer (StorageObject)**: a recursive object serialization format used for each buffer.

All integer fields are **Little-Endian**.

## 1. Container Layer (SPC0 / StorageContainer)

An `.spc` file contains a header followed by an encrypted body.
The body contains a table of buffers and a contiguous data region holding the (optionally compressed) buffers.

### 1.1 File Header (0x50 / 80 bytes)

The header is **not encrypted**. Everything after the header (offset `0x50`) is encrypted.

| Offset | Size | Type | Description |
|--------|------|------|-------------|
| 0x00   | 4    | char[4] | Magic signature. Stored bytes are `0CPS` (reads as `SPC0`). Value as LE `u32` is `0x53504330`. |
| 0x04   | 4    | uint32 | File checksum (custom, see below). When computing, this field is treated as `0`. |
| 0x08   | 8    | uint64 | Number of buffers `N`. |
| 0x10   | 8    | uint64 | Offset to buffer table (from file start). Usually `0x50`. |
| 0x18   | 4    | uint32 | Encryption seed. |
| 0x1C   | 4    | -      | Padding (alignment to 8 bytes). |
| 0x20   | 8    | uint64 | Offset to buffers data region (from file start). |
| 0x28   | 40   | uint32[10] | Reserved (typically zero). |

**Note**: The file size is *not stored* in the header; use the actual file length.

### 1.2 Checksum

The checksum is a ones-complement sum (with ones-complement input) over the **entire decrypted file**.

Algorithm (pseudocode):

1. Set the checksum field at offset `0x04` to `0`.
2. Sum the bitwise-NOT of each value in order:
   * as many `uint32` as possible,
   * then remaining `uint16`,
   * then remaining bytes.
3. Return `~sum`.

The checksum is computed **before encryption** when writing the file. Therefore, when verifying:

1. Decrypt the body (offset `0x50..EOF`).
2. Zero out the checksum field.
3. Compute and compare.

### 1.3 Encryption ("Avalanche" XOR)

The file body (everything after the 80-byte header) is encrypted in-place as an array of `uint32`.
The body is padded so its length is a multiple of 4 bytes.

Constants used by the suite:

* Key: `0xFEEDBEEF`
* Block size: `4` (not stored in the file)

Helper function:

* `repmat(x) = ~((x & 0xFF) * 0x01010101)` (replicate low byte across a `u32` then invert)

Decryption (what you need for parsing):

1. Interpret the encrypted body as `num_words = body_len / 4` words.
2. Initialize `key = (0xFEEDBEEF ^ seed) + repmat(num_words)`.
3. For `j = 0..block_size-1`:
   * For `i = j; i < num_words; i += block_size`:
     1. `temp = ~word[i]` (this is based on the **ciphertext** word)
     2. `word[i] ^= key`
     3. `key += temp`
     4. `key += repmat(i)`

Encryption uses the same structure, but the key update uses the complemented **post-XOR** word instead.

### 1.4 Buffer Table

After decryption, the buffer table can be read at `buffers_table_ofs`.
It contains `N` entries.

**Entry Structure (24 bytes per buffer, 8-byte aligned)**:

| Offset | Size | Type   | Description |
|--------|------|--------|-------------|
| 0x00   | 1    | uint8  | Encoding flag |
| 0x01   | 7    | -      | Padding |
| 0x08   | 8    | uint64 | Offset to buffer bytes **relative to** `buffers_data_ofs` |
| 0x10   | 8    | uint64 | Encoded size (bytes on disk, i.e. *before* decompression) |

**Encoding flags**:

* `0`: None (raw)
* `1`: RLE8
* `2`: RLE0

### 1.5 Compression / Encoding

Each buffer is optionally compressed **independently**.

#### RLE8

Data is read as pairs of bytes: `[count, value]`.

* `count`: number of times to repeat `value` (1..255 in files generated by the suite).
* Example: `03 AA` → `AA AA AA`

#### RLE0

RLE0 is a variable block-size run-length encoding.

Decoding algorithm:

* Start with `block_size = 1`.
* While not EOF:
  1. Read `occurrence` (`u8`).
  2. If `occurrence == 0`:
     * Read a new `block_size` (`u8`).
     * Read `occurrence` again (`u8`).
  3. Read `block_size` bytes as `block`.
  4. Output `block` repeated `occurrence` times.

### 1.6 Buffer Extraction Summary

1. Read the 80-byte header.
2. Decrypt the file body (offset `0x50..EOF`).
3. Verify checksum on the decrypted bytes (checksum field treated as 0).
4. Read the buffer table and slice each buffer from `buffers_data_ofs + entry.offset` of length `entry.size`.
5. Decompress each buffer using the entry's encoding.
6. Parse each decompressed buffer as a packed `StorageObject`.

---

## 2. Object Layer (StorageObject)

After decrypting and decompressing, each buffer contains a serialized `StorageObject`.
This is a recursive structure containing variables and child objects.

### 2.1 Object Header (104 bytes)

| Offset | Size | Type   | Description |
|--------|------|--------|-------------|
| 0x00   | 8    | uint64 | Offset to **Type Name** string *(within Strings section)* |
| 0x08   | 8    | uint64 | Offset to **Owner Name** string *(within Strings section)* |
| 0x10   | 8    | uint64 | Offset to **Object/Var Name** string *(within Strings section)* |
| 0x18   | 8    | uint64 | Number of variables |
| 0x20   | 8    | uint64 | Number of children |
| 0x28   | 16   | struct | **Strings section** `{offset, size}` *(offset from start of this object)* |
| 0x38   | 16   | struct | **Variables table** `{offset, size}` *(offset from start of this object)* |
| 0x48   | 16   | struct | **Children table** `{offset, size}` *(offset from start of this object)* |
| 0x58   | 16   | struct | **Data section** `{offset, size}` *(offset from start of this object)* |

**Important offset bases**:

* The four section descriptors (`strings/vars/children/data`) are offsets **from the start of the object buffer**.
* String offsets in the header and descriptors are offsets **within the Strings section**.
* Data offsets in variable/child descriptors are offsets **within the Data section**.

### 2.2 Sections

1. **Strings section**: a blob of null-terminated strings (an empty string is just a single `\0`).
2. **Variables table**: array of variable descriptors.
3. **Children table**: array of child descriptors.
4. **Data section**: raw bytes for variable payloads, plus nested packed children.

### 2.3 Variable Descriptor (40 bytes)

| Offset | Size | Type   | Description |
|--------|------|--------|-------------|
| 0x00   | 8    | uint64 | Owner name offset *(within Strings section)* |
| 0x08   | 8    | uint64 | Variable name offset *(within Strings section)* |
| 0x10   | 8    | uint64 | Type name offset *(within Strings section)* |
| 0x18   | 8    | uint64 | Data offset *(within Data section)* |
| 0x20   | 8    | uint64 | Data size (bytes) |

### 2.4 Child Descriptor (32 bytes)

| Offset | Size | Type   | Description |
|--------|------|--------|-------------|
| 0x00   | 8    | uint64 | Owner name offset *(within Strings section)* |
| 0x08   | 8    | uint64 | Child object name offset *(within Strings section)* |
| 0x10   | 8    | uint64 | Data offset *(within Data section)* |
| 0x18   | 8    | uint64 | Child object size (bytes) |

The child object's bytes are stored in the parent Data section and start with their own 104-byte object header.

---

## 3. Standard Buffer Contents (Spectrum Analyzer `.spc`)

The container does not store buffer names directly.
In Spectrum Analyzer `.spc` files, each top-level `StorageObject` in the container uses:

* `owner_name == ""` (empty)
* `var_name` equal to the buffer name (e.g. `"data"`)

### 3.1 Buffer: `"data"` (root object: `("", "data")`)

This contains the primary spectral data and camera identifier.

* Type name: `typeid(SpectreFile).name()` (typically `"class SpectreFile"` on MSVC)
* Children:
  * `m_data` (type: `storage_vector<double>`) — intensity values
  * `m_blank` (type: `storage_vector<double>`) — blank/reference spectrum
  * `m_uid` (type: `storage_string`) — capture device identifier

`storage_vector<double>` encoding (both `m_data` and `m_blank`):

* Stored as a child object whose variables represent elements.
* Type name: `typeid(storage_vector<double>).name()` (e.g. `"class storage_vector<double>"` on MSVC)
* Number of variables equals the pixel count.
* Each element is stored as:
  * owner name: `typeid(storage_vector<double>).name()`
  * variable name: `""` (empty string)
  * type name: `typeid(double).name()` (typically `"double"`)
  * size: 8 bytes
  * data: IEEE-754 64-bit float, little-endian

`storage_string` (`m_uid`) encoding:

* Stored as a child object.
* Type name: `typeid(storage_string).name()` (e.g. `"class storage_string"` on MSVC)
* Contains two variables:
  * `size`: owner=`typeid(storage_string).name()`, type=`"size_t"`, size: 4 or 8 bytes depending on 32/64-bit build
  * `data`: owner=`typeid(storage_string).name()`, type=`"char"`, size: matches `size` value, includes trailing `\0`

### 3.2 Buffer: `"calibration"` (optional)

If present, the `calibration` buffer is stored directly as a `storage_vector<double>` containing 4 coefficients.

**Wavelength calculation**:

Let `N` be the pixel count and `i` a pixel index (`0..N-1`). Normalize to `x ∈ [-1, 1]`:

$$x = \frac{2i}{N - 1} - 1$$

The suite evaluates a 3rd-order Legendre expansion:

$$\lambda(x) = \sum_{k=0}^{3} a_k P_k(x)$$

Where $P_k(x)$ are the Legendre polynomials:

| k | $P_k(x)$ |
|---|----------|
| 0 | $1$ |
| 1 | $x$ |
| 2 | $\frac{1}{2}(3x^2 - 1)$ |
| 3 | $\frac{1}{2}(5x^3 - 3x)$ |

### 3.3 Buffer: `"config"` (optional)

If present, the `config` buffer stores configuration parameters from `wndParametersDialog`.
Each parameter is stored as a child object using the `dynamic_var<T>` wrapper.

**`dynamic_var<T>` encoding**:

For primitive types (int, double, bool), `dynamic_var<T>` stores:
* Type name: `typeid(dynamic_var<T>).name()` (e.g. `"class dynamic_var<double>"` on MSVC)
* Child object: None
* Variable `"data"` with:
  * Owner: `""`
  * Type: `typeid(T).name()` (e.g. `"double"`, `"int"`, `"bool"`)
  * Data: The raw bytes of the value

**Stored fields** (as defined in `camconfig.cpp`):

| Field | Type | Description |
|-------|------|-------------|
| `smoothing` | int | Smoothing kernel size |
| `average` | int | Number of frames to average |
| `sgolay_window` | int | Savitzky-Golay window size |
| `sgolay_order` | int | Savitzky-Golay polynomial order |
| `sgolay_deriv` | int | Savitzky-Golay derivative order |
| `raman_wavelength` | double | Raman laser wavelength in nm |
| `medfilt` | bool | Median filter enabled |
| `baseline` | bool | Baseline removal enabled |
| `sgolay` | bool | Savitzky-Golay filter enabled |
| `axis` | AxisType | Preferred axis type |



**AxisType enum**:

| Value | Name |
|-------|------|
| 0 | Pixels |
| 1 | Wavelengths |
| 2 | RamanShifts |

**Raman shift calculation** (cm⁻¹):

$$\Delta\nu = 10^7\left(\frac{1}{\lambda_{\text{laser}}} - \frac{1}{\lambda_{\text{pixel}}}\right)$$

---

## 4. Summary of Data Fields

| Field | Source location | Description |
|-------|-----------------|-------------|
| Intensity | `data` → `m_data` | Y-axis spectral counts. |
| Reference | `data` → `m_blank` | Blank/dark spectrum. |
| Serial / UID | `data` → `m_uid` | Capture device identifier. |
| Wavelength axis | `calibration` (if present) | X-axis in nm, computed from 4 model coefficients. |
| Raman shift axis | `config` → `raman_wavelength` + `calibration` | X-axis in cm⁻¹, computed from laser wavelength and wavelength axis. |
